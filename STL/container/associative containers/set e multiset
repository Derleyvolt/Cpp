É implementado como uma árvore binária de busca.


set e multiset organizam seus elementos automaticamente de acordo com um certo "sorting criterion"/ critério de organização.
A diferença entre os dois tipos de containers é que multisets permitem elementos duplicads, e o set não.

template <typename T,
          typename Compare = less<T>,
          typename Allocator = allocator<T>>
class set;

template <typename T,
          typename Compare = less<T>,
          typename Allocator = allocator<T>>
class multiset;

Os elementos de um set ou multiset pode ter qualquer tipo T que é comparavél de acordo com o "sorting criterion". O segundo template
adicional define o "sorting criterion". Se um "sorting criterion" especial não é passado, o padrão "criterion less" é usado.
A função objeto "less" organiza os elementos comparando-os com o operador<.

O "sorting criterion" deve definir um "strict weak ordering".

note que isto significa que você tem que distinguir entre menor e igual. Um critério tal como o operador <= não preencheria este
requerimento. Baseado nessas propriedades (que eu não coloquei aqui), o "sorting criterion" também é usado para checar equivalência.
isto é, dois elementos são considerados duplicados se nenhum é menor do que o outro. Para multisets, a ordem dos elementos equivalentes
é aleatória, mas estável. Portanto, inserções e deletações preservam a ordem rela- tiva de elementos equivalentes.

HABILIDADES DE SETS E MULTISETS:

Como todo container associativo padronizado, sets e multisets são geralmente implementados como árvores binárias balanceadas.
A maior vantagem de organização automatica é que uma árvore binária executa bem quando elementos com um certo valor são buscados.
De fato, buscas tem complexidade logaritmica. Embora, organização automatica também impõe uma importante restrição em sets e multisets:
Você pode não mudar o valor de um elemento diretamente, porque isso pode comprometer a ordem correta.

De fato, sets e multisets são tipicamentes implementados como red-black trees, que são bons tanto para mudar o número de elementos e 
busca de elementos. Eles garantem no máximo dois relinks internos em inserções e que o caminho mais longo é no máximo duas vezes maior
que o caminho mais curto até uma folha. Portanto, para modificar o valor de um elemento, você deve remover o elemento tendo o valor 
antigo e inserir um novo elemento com um novo valor. As interfaces refletem esse comportamento:

• Sets e multisets não fornecem operações para acessar o elemento diretamente.
• acesso indireto via iterators tem a limitação que, do ponto de vista de iterators, o valor do elemento é constate.

================================= OPERAÇÕES SET E MULTISET =========================================================

Você pode definir um "sorting criterion" de duas maneiras:

1. Como um parâmetro template. Por exemplo:

std::set<int, std::greater<int>> coll;

Neste caso, o "sorting criterion" é parte do tipo. Portanto, o sistema de tipos garante que apenas containers com o mesmo "sorting
criterion" possam ser combinados (ou seja, um set<int, std::greater<int>> não pode ser atribuido a um set<int, std::less<int>>. Isto
é uma maneira usual para especificar o "sorting criterion". Para ser mais preciso, o segundo parâmetro é o tipo do "sorting criterion".
Um "sorting criterion" concreto é a função objeto que é criada com o container. Para fazer isso, o construtor do container chama o 
construtor padrão do "sorting criterion".

2. Como um parâmetro do constructor. Neste caso, você pode ter um tipo para vários "sorting criterion" que permite ter diferentes
valores iniciais ou estados. Isto é útil quando processando o "sorting criterion" em tempo de execução e quando são necessários
"sorting criterion" diferentes mas dos mesmos dados. Se nenhum "sorting criterion" especial é usado, o padrão "sorting criterion",
função objeto less<>, é usado, o qual organiza os elementos usando o operador<.  Note que o "sorting criterion" também é usado para
checar equivalência de dois elementos no mesmo container (exemplo, para encontrar duplicatas). Portanto, quando o padrão "sorting
criterion" é usado, a checagem por equivalência de dois elementos parece com isso:

if (! (elem1<elem2 || elem2<elem1))

Isto tem três vantagens:
1. Você precisa passa apenas um argumento como "sorting criterion".
2. Você não precisa fornecer o operador == para o tipo de elemento.
3. Você pode ter definições contrarias entre equivalência e igualdade (embora, isto pode uma fonte de confusão).

Checando por equivalência desta meneira leva um pouco mais de tempo porque duas comparações podem ser necessárias para avaliar
a expressão anterior. Note, embora, que se o resultado da primeira comparação retorna true, a segunda comparação não é avaliada.

Note também que se dois containers são comparados pelo operador ==, os elementos em ambos os containers são comparados usando seus
operadores ==, no qual significa que o operador == tem de ser fornecido pelo tipo elemento.

O construtor para um início e o fim de um range poderia ser usado para inicializar o container com elementos de um container que
possui outro tipo, ou arrays, ou de um "standard input".

Initializando um container com os elementos de um outro container:

std::list<int> l; // l é um linked list de inteiros
...

// copia todos os elementos da lista como float em um vector
std::vector<float> c(l.begin(),l.end());

Operação                         Efeito

set c                            Default constructor; creates an empty set/multiset without any elements
set c(op)                        Creates an empty set/multiset that uses op as the sorting criterion
set c(c2)                        Copy constructor; creates a copy of another set/multiset of the same type (all elements are copied)
set c = c2                       Copy constructor; creates a copy of another set/multiset of the same type (all elements are copied)
set c(rv)                        Move constructor; creates a new set/multiset of the same type, taking the contents of the rvalue rv
set c = rv                       Move constructor; creates a new set/multiset of the same type, taking the contents of the rvalue rv
set c(beg,end)                   Creates a set/multiset initialized by the elements of the range [beg,end)
set c(beg,end,op)                Creates a set/multiset with the sorting criterion op initialized by the elements of the range [beg,end)
set c(initlist)                  Creates a set/multiset initialized with the elements of initializer list initlist
set c = initlist                 Creates a set/multiset initialized with the elements of initializer list initlist (since C++11)
c.~set()                         Destroys all elements and frees the memory


Aqui, set pode ser um dos seguintes tipos:

set                              Efeito

set<Elem> A                      set that by default sorts with less<> (operator <)
set<Elem,Op> A                   set that by default sorts with Op
multiset<Elem> A                 multiset that by default sorts with less<> (operator <)
multiset<Elem,Op> A              multiset that by default sorts with Op




